================
FT_TRANSCENDENCE
================

---------
COWORKING
---------
Usage of Trello, github, slack and discord.

---------------
WEB DEVELOPMENT
---------------
World Wide Web (www), grouping of all documents on the web accessible through URLs(uniform resource locator)

A server is a computer connected to the www, it contains an IP address to identify itself, this IP address can be associated with an URL, which is a non-random name for easier identification.

Web browser, is a software application that allows access to the world wide web via URLs. The web browser transforms the URL into an IP address using the DNS (domain name system), it sends http requests towards that ip address to receive the requested content.

Webservers serve an application/platform/website on the web. They receive web browser requests and send back responses. They often run on an external server, which is a computer with no visual display that runs 24/7, waiting for client-servers to make requests.
Cloud computing is the on-demand availability of computer-system-resources, especially data-storage and computing-power. Large clouds consist of multiple servers connected/working together.

HTTP
The language used between servers to communicate.
http requests are made by a web browser and follow a specific syntax, they can request content from the webserver or even post content on the webserver, allowing the client to interact with the webserver.
http responses are made by the web server and follow a specific syntax, they can send HTML pages for the browser to display.
http stands for hypertext transfer protocol, hypertext are documents that include links to other documents.

Structure of a request:
First line: method + request targer (URL) + HTTP version (HTTP/1.1)
Header fields: Optional extra information about request
Separation empty space
Body: Content of the request

Structure of a response:
Status line: HTTP version (HTTP/1.1) + status code + status short description
Header fields: Optional extra information about response
Separation empty space
Body: Content of the response

The different HTTP methods for requests are:
GET: requests representation of specified resource, specified resource is indicated by URL.
HEAD: The HEAD method asks for a response identical to that of a GET request, but without the response body, is used to verify if any erros.
POST: used to submit an entity to the specified resource, often causing a change in state on the server.
PUT: replaces all current representations of the specified resource with the submitted request entity.
DELETE: deletes the specified resource.

The different status codes for responses are:
200: OK, successful request
201: Created, for put and post methods
400: Bad request, invalid syntax
404: Not found, the URL is not recognized
405: Not allowed, the resource does not accept the method
500: Internal server error, situation the server does not know how to handle

WEB PLATFORM
A web platform consists of a back-end and front-end. 
Back-end acts as web-server(answer HTTP request) and data-base-manager.
Front-end refers to the pages send by web-server to client-server, that the client's web browser will visually display, creating an user interface (UI). 
Different programming languages can be used for the back-end and front-end development.

---------
FRONT-END
---------

HTML & CSS
The HyperText Markup Language, or HTML is the standard markup language for documents designed to be displayed in a web browser. 
CSS describes how HTML elements should be displayed and is thus a styling language.
Those are the only languages a web browser can display.

JAVASCRIPT
Is a high-level-language used both for front-end and back-end.
The most often used frameowrks in front-end are react and angular and in back-end is nodejs.
Front-end javascript allows for dynamic webpages, plus is more easy to write than HTML/CSS code.
Through API, front-end javascript can contact the back-end for data-base-infomation leading to dynamic pages.
The web browser has to first transform javascript to HTML/CSS before display, it gets called from an HTML with the script tag, javascript can be viewed as a high-level-language for dynamic HTML/CSS code generation.

TYPESCRIPT
It is a strict syntactical superset of JavaScript and adds optional static typing to the language. TypeScript is designed for the development of large applications and transcompiles to JavaScript.
By making use of static typing it makes the code more readable and allows compile-time-errors..

REACT
React is a free and open-source front-end JavaScript library for building user interfaces or UI components. 
Material-UI is a react framework that contains pre-made UI components.

--------
BACK-END
--------

NODEJS
Node.js is a back-end JavaScript runtime environment that executes JavaScript code outside a web browser.

EXPRESS
Express.js, or simply Express, is a back end web application framework for Node.js. It is designed for building web applications and APIs way faster.

POSTGRESQL
PostgreSQL is a commonly used and advanced database-management-system, used to store and retrieve data. 

APIs
An application programming interface is a connection between computers or between computer programs. It allows communication between the front-end and back-end, whereby the back-end gathers data from a data-base to produce dynamic front-end pages.

==================
LEARNING MATERIALS
==================
! -> consumed
| -> partly consumed

Books;
Javascript: The good parts - O'Reilly !

Tutorials;
https://www.youtube.com/watch?v=ahCwqrYpIuM - Typescript - The Basics - 12m !
https://www.youtube.com/watch?v=BwuLxPH8IDs - TypeScript Course for Beginners 2021 - 3h16m !
https://www.youtube.com/watch?v=NjN00cM18Z4 - TypeScript for React - 51m !
https://www.youtube.com/watch?v=gp5H0Vw39yw - Typescript full course for beginners - 1h34m !
https://www.tutorialspoint.com/typescript/index.htm - Typescript written complete tutorial !

https://www.youtube.com/watch?v=dOnAC2Rr-6A - Javascript full course for beginners to advanced - 4h11m !
https://www.youtube.com/watch?v=PkZNo7MFNFg - Learn JavaScript - Full Course for Beginners - 3h26m !
https://www.youtube.com/watch?v=DHvZLI7Db8E - Javascript promises - 11m !
https://www.youtube.com/watch?v=V_Kr9OSfDeU&t=0s - JavaScript Async Await - 7m !
https://www.youtube.com/watch?v=cuEtnrL9-H0 - Fetch API - 6m |

https://www.youtube.com/watch?v=hQAHSlTtcmY - Learn React In 30 Minutes - 27m |
https://www.youtube.com/watch?v=MRIMT0xPXFI - Learn React in 5min (2020) - 5m !
https://www.youtube.com/watch?v=w7ejDZ8SWv8 - React JS Crash Course 2021 - 1h48m !
https://www.youtube.com/watch?v=vyJU9efvUtQ - Material UI React Tutorial - 42m !

https://www.youtube.com/watch?v=Oe421EPjeBE - Node.js and Express.js - Full Course - 8h16m !

https://www.youtube.com/watch?v=qw--VYLpxG4 - PostgreSQL full course - 4h20m !

personal project:
Latin vocabulary exerciser.

Courses;
https://www.codecademy.com/learn/learn-html - 9h
https://www.codecademy.com/learn/learn-css - 10h
https://www.codecademy.com/learn/introduction-to-javascript - 20h
https://www.codecademy.com/learn/learn-intermediate-javascript - 10h
https://www.codecademy.com/learn/learn-typescript - 10h
https://www.codecademy.com/learn/react-101 - 20h
https://www.codecademy.com/learn/learn-node-js - 7h
https://www.codecademy.com/learn/learn-express - 4h
https://www.codecademy.com/learn/paths/design-databases-with-postgresql - 30h
https://www.codecademy.com/learn/paths/full-stack-engineer-career-path - 6months

Shared Slack links;
https://www.sitepoint.com/react-with-typescript-best-practices/
https://dev.to/mychal/protected-routes-with-react-function-components-dh
https://www.infoq.com/articles/typescript-mysql/

==========
JAVASCRIPT
==========
OFFICIAL DOCUMENTATION
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference

LINES & COMMENTS
; -> at end of line indicates the end but is not mandatory
// -> single line
/* */ -> multiple lines

VARIABLES
Variables can take any type as Javascript is loosely typed.
Different primitive types: number, string, boolean, null, undefined, any, object, array, Function.

var keyword is used in front of variable name at declaration to indicate simple variable, available in function scope or as global variable.
let keyword declares variable solely in block scope.
const keyword creates constant variables, meaning their value cannot change, available in block scope.

All types have access to different methods.
Strings can be concatenated with +.
Strings are immutable you can not change a single char inside it, only the whole string at once can be changed.
Push and pop methods can make arrays dynamic.
Date objects contain a number that represents miliseconds since 1 January 1970 UTC.
Primitive values are passed by copy/value and objects by referene.
typeof keyword is used to receive the current type of a variable.

Objects can also be created which are considered as one variable but contains multiple variables, they work like python dictionnaries..
Object.freeze(objectname) can be used to make the variables inside the object constant.
Classes contain variables and methods (functions that use those variables, to access those variables this keyowrd is used), a constructor also exist that is called at construction and can take parameter values. 
With extend keyword classes, heritage from another class is possible, to call the parent class contructor use super().

Spread operator consist of ...variable as keyword, it allows the extract the inside of string/array/object. 
If string to array [..variable, ...variable2] it will transform each letter of the string into strings inside an array. 
If array to array [..variable, ...variable2] it extraxts each element in the array into elements in the new array.
If object to object {..object1, ...object2} it extracts each variable in the object into new object.
One can also change a value that has just been spread from an object like this {..object1, objectVariable:newValue}. 
With ! you can call the opposite value of a variable like this {..object1, objectVariable:!objectVariableValue}

ARITHMETIC
+ - / % *
+= -= /= %= *= -> operator on self

FUNCTIONS
Functions are indicated with function keyword, it can take parameters, perform actions with them and return a value, if it does not return a value, it returns undefined.
A lot of built-in functions and methods already exist.

Map function on arrays, performs function on each element inside the array, transforming it.
Filter takes function that returns a boolean and decides to remove elements from the array or not.
Reduce adds on all the elements in an array returning one.

Functions can take other functions as parameters which is also called callbacks.
Default parameters take in a default value with = operator.
Rest operator consist of ...arg as function parameters and means undefined/unlimited number of parameters for the function.

Anonyomous functions do not have a name but are given as value to a variable, the variable thus becomes the function and becomes like a function pointer, this is confusing but part of javascript.
Arrow and ternary functions allow for shorter syntax of functions and are useful for non-reusable-functions used as parameters.

A generator function is indicated with the function* keyword.
Generator functions yield values back, meaning it returns multiple times instead of one time. 
A variable equaling a generator function, becomes a generator object, whereby the multiple variables inside the generator object can be accessed with next method until it equals undefined.

LOOP, CONDITIONS, COMPARISON/LOGICAL OPERATORS
for can be used to loop over an array and can be used as usual with an index.
while loop are also possible.
do while loops allow you to use a while loop whereby the loop gets entered at least one time.
break keyword breaks out of the loop and continue restarts the loop.
if, else if, else conditions exist.
Comparison operators without type coercion; === <== >== !== < >
Type coercion is not recommended and means for example "0" == false -> true
Logical operators; && || !(statement)

EXPORT IMPORT 
export as keyword can be used in front of functions/variables that you want to use in another file.
import keyword must than be used into this other file to import the "exported" functions/variables from the first file.
You can import all or only certain functions/variables from that file. 
You can also import as a certain name, meaning the imported functions can only be accesed through this name, avoiding function/variables with duplicate names.
export default means you only export one element from the module.

PROMISES & SYNC AWAIT & FETCH & ERRORS
Javascript does not contain multiple-threads, but it can send an external request and while waiting for a response execute other code until the response arrives and the single thread comes back to it, this is called an event loop and makes us gain time.

Promises are useful for external actions that take time, such as making a request to an API, the promise may hold a value at some point in time or not, it promises a value will come.
A promise is an object, that takes one parameter, this parameter is a function, 
this function takes two parameters (resolve and reject), this function performs an action that can succeed or fail, 
if it succeeds the promise gets resolved else it gets rejected, this is indicated in code by using the parameter functions (resolve and reject) that can take an arbitrary number of parameters.
The promise object has a then method that takes a function that gets executed if the promise got resolved, this function thus takes the same number of parameters as the resolve function did.
The promise method also has a catch method that takes a function that gets executed if the promise got rejected, this function thus takes the same number of parameters as the resolve function did.
Promise.all function takes as argument an array of promises and calls all of them simultaneously, they will all have the same following then() and catch().

Async keyword used in front of functions, indicates that the content of the function will contain the await keyword and needs to be handled asynchronously.
Await keyword allows to wait for the promise to be returned, while it waits for the promise it continues to execute code outside of the asynchronous function, and once the promise has returned it comes back to the await keyword to take the final value of the promise and continue the asynchronous function. 
Without the await keyord the promise without its final value is instantly returned.
If the promise gets rejected the error won't be catched, the solution is to use the try-catch statement inside the asynchronous function to catch the error in case of a rejected promise.

The Fetch API provides an interface for fetching resources. The fetch method can send http requests to APIs for example.
The first and only mandatory parameter of the fetch function is the URL to the resource you want to fetch, the second argument is by default an HTTP GET request. 
The second argument is an object representing an HTTP request, whereby HTTP method, headers, body, ... can be adapted.
When sending a body, set in headers: Content-Type: application/json, in body set an object that you transform into json with JSON.stringify function.
Fetch will return a promise, if the promise got resolved a response object containing the HTTP response is returned. 
To check if an HTTP error got returned the response.ok can be verified.
To view the json body of the response we call response.json() which also returns as a promise if resolved the parsed JSON.

Try-catch statement can be used to catch errors. Whereby if a code gets generated inside the try scope, code inside the catch scope gets executed.

==========
TYPESCRIPT
==========
ENVIRONMENT
-----------
npm is a package manager for the JavaScript programming language nodejs framework, also called node package manager.
npm can be used to download typescript, which will give access to tsc for compiling .ts.
npm install/uninstall can be used for downloading libraries.
Brew install typescript, leads to both npm and tsc installed.
tsc will transform .ts to .js. As browsers and Node.js can only compile js.
tsconfig.json can be used to configure tsc.

Most used front-end stack is typescript+react and back-end stack typescript+nodejs+express.js.
With react, nodejs and express.js being frameworks of javascript.

VScode recommended extensions;
ESLint, for javascript code check.
Path Intellisense, for recommended file paths, useful for front-end development when referring to other files.

COMPILATION
-----------
Browsers cannot directly compile .ts thus it has to be transformed into .js.
Use tsc to compile .ts to .js.
HTML files contain a script tag that can refer to a particular .js.
Those HTML files have to be compiled in the browser by entering the absolute path towards the file in the search bar, go to on chrome more tools -> developer tools to view the console.

tsc -w will constantly recompile files each time you make a change
tsc --init will let you compile all files from root directory next time you use tsc. 
A .json file will be created wherein compilation adjustments can be done.
In the .json files to compile can be excluded.
Target feature are used to indicate the javascript version to compile to, es5 is older more compatible version and es6 is newer version.
Lib feature is used to indate used libraries.

ADDITIONS
---------
The following additions lead to more readable/ordered/shorter code and compile-time-error-detection, especially useful for large projets.
Types, typescript is strongly typed while javascript is loosely typed.
New features.
Next-gen Javascript features, compiled down for older browsers.

TYPE:
Strong typing can be done implicitly or explicitly. 
Implicitly leads to the compiler assuming the type based on the variable given value.
Explicit type declaration needs after variable declaration a : followed by the choosen type.

Function arguments can also be strong typed. Function returns can also be strong typed and set to void (which returns undefined) by adding the type at end of function declaration.
Never type can be used as function return type for functions that never end, either because they end the program or because they infinite loop, it makes the code more readable but technically void can be used too.

Different types: number, string, boolean, null, undefined, any, object, array, Function.

Objects contain multiple variables like a C structure would, and can be strong typed with : {x: type, y:type, ...}, interfaces allow the creation of a type out of it, so objects can be viewed as a single instance.
Arrays can be strong typed by introducing directly following the declared type the [] symbol.
Tuples in javascript are like fixed-size-arrays not necessarily of lenght 2, they can be strong typed, whereby each value inside the tuple can independently be strong typed, indicated by [type, type, type].
Variables can hold functions by acting as function pointers in C and be of type Function.
Type "any" leads to the freedom of a variable to become any type and even change type over the course of the program, comes down to simple javascript.
Different types can take in different values and have access to different methods like classes.

Multiple types can explicitly be declared by using |, those are called union types.
Aliases can be made with keyword type ... = , often they are used with unions, to make unions have one name.
Literal types, are types with pre-defined potential values, unions can be used to have a choice between multiple values.

Casting is called type assertion in typescript and is used to for example tell that a variable with any type is in fact a number for example.

NEW FEATURES:
Shape of object can be defined with an interface, wherein variables and their type are defined. An interface is like a structure in C it is an object declaration that can be re-used as a type.
Classes also exist and function like python classes, with access modifiers(private, public, protected) in front of declaration (no access modifier meaning public) and this, this.variable keyword, inheritance is possible with the extends keyword, it can inherit from other classes but also from interfaces, static keyword can be used on member variales...
Custom types need to be allocated memory with the new keyword and call to constructor at declaration for classes.

Question mark in front of parameter variables, indicates that those parameters are optional, if not used it will become equal to undefined.
Rest parameters allow for unlimited and undefined amount of parameters.
Default parameters allow giving to parameters a default value.
Lambda expression or arrow functions are one-line-functions indicated with an arrow in typescript, ternaries also exist.
Exclamation marks in typescript at end of line, means used function/variable is not equal to null or undefined because it will be declared later.

Export keyword allows the creation of modules, modules are files that can be imported on to other files, with the exported declarations being accessible to the file that imported.
Namespces are used to group code together inside it, and avoids problem of overwriting due to everything being in a global scope in javascript.

Generics are like c++ templates whereby function parameters or classes take a to-be-declared-type, by using it in combination with the extend keyword, you can limit the number of types that can be choosen from.

=====
REACT
=====
SETUP
-----
npx executes npm(javascript nodejs package manager) binaries.
Use it to setup the default react application with "npx create-react-app .".

Once the app is setup, different commands can be used;
npm start -> starts the development environment
npm run build -> builds the application, creates production version of application that can be deployed on server and accessed from the internet.

Once the app is setup differt default files appeared;
In public/index.html we can find the index file that contains one div tag named root wherein the whole react-generated-html will come. In src/index.js we can view that App.js gets rendered into the div tag root.
In src/App.js a default react application is written inside the function app, this function/component will be the core of the app, like a main is to the c langauage.
To prepare for writing own code, you can clean the default app by for example;
All files in src/ besides index.js and App.js can be removed.
Make the app function return null, remove the App.css and logo.svg imports in src/App.js.
In src/index.js all serviceWorker code, index.css, serverWorker imports can be removed.

For "nmp run build" the webpack library is necessary to transform JSX/components into javascript and bundle the whole app into one file; bundle.js (that the browser can run).
After bundling the application a build directory appears, that is ready for server deployment. 
Distinction can be made between development environment (everything besides the build folder) and production application (build folder). The production application or build folder can deploy the application on a server on its own.
For server deployment use the following two commands "npm install -g serve" followed by "serve -s build". 

The google chrome extension "React developer tools" allows for more information on state of application. 

FEATURES
--------
JSX
Is a syntax similar to HTML with some differences like;
Javascript code can be implemented by indicating it between { }, if statement can be done with ternary operator herein.
A name between tags <name /> indicates a component and is thus used to reuse components.
Those components can take arguments like that <componentName argumentName=argumentValue/>.

Javascript array method map can be used to loop over all elements/components of an array, to return them all.
In both JSX and HTML ${} can be used to take expressions, for example do an if with a ternary operator.

css can be added inside tags allowing for styling with style= an objects and that can contain variables such as color, backgroundcolor, cursor... Such a css object can be created once and re-used.

To create a button simply use <button></button>, in tag onClick={function} allows you to call a function once someone clicks the button, this is an example of an event.

To use icons, download them like this "npm install react-icons".
Now you can import components from react-icons library, those components/icons can be added in the JSX like you would add any other component.

COMPONENT
Are react functions that return a JSX code, that thus enables reusable components.
Components can contain other components like functions can call other function and they all in the end come back to the app-component/main, their name must begin with a capital letter.

Function arguments are called props, the function will contain one prop called props that takes all the potentially passed arguments and those arguments can be accessed inside the function with props.passedArgumentName.
By declaring outside the component the variable componentName.defaultProps we can indicate the default values of the props in a dictionnary/object format.

Components are usually functions but can also be classes that inherit from React.Component and have render method.

To return multiple elements they can be wrapped between empty tags <> </> creating one fragment.
Often one file exists per component and all components are inside src/components
Inside components functions can be written that can access the variables inside the component.

STATE
Is a dynamic form of storage that lives inside of our components, in the end it allows for direct updates of pages (without need to reload).
React uses a separate DOM representation called the virtualDOM, it compares it to the real DOM with the reconciliation algorithm, to determine if the page has to be updated. 

For this use the state hook useState(value) that returns an array with two values, the first one being the value and second a setter function, the setter function can be used after a particular action and is able to change the value, which will directly be updated on the page.

EFFECTS
Functions get called once a component is created(mounts), updated or removed(unmounts) from the page.

This is done by the hook useEffects(function, triggers[]), the function gets called once a component mounts or one of the values inside the trigger[] array change, finally this function can return a function that gets called once our component unmounts.

MATERIAL UI
-----------
Material UI is a framework for react that contains pre-made components.

SETUP
First install the library with "npm install @material-ui/core" after having started a react application.
In the package.json file dependencies section the material-ui/core library will become visisble.

USE
https://material-ui.com/components/box/ -> documentation on all component and their parameters possibilities.

To access a button component for example "import Button from '@material-ui/core/Button'", afterwards Button can be ased as a component. 
You can give it the variant, color, size parameter for styling for example.
style parameter can be used for even more customization.
Other parameters for functionality are for example href, onClick, disabled..

For access to icons first "npm install @material-ui/icons".
To access them for example use "import DeleteIcon from @material-ui/icons/Delete", now DeleteIcon can be used like any other component.

To create own styles "import { makeStyles } from '@material-ui/styles'".
Use the makseStyles function that returns a function and takes in an object with the different style parameters.
Indicate inside a compenent's className parameter the style to style the component.
To access colors "import { orange } from '@material-ui/styles'.

To create own themes "import { ThemeProvider, createMuiTheme } from '@material-ui/styles'".
Use createMuiTheme to create a theme by giving it an object with theme specifications.
Wrap componenets around <ThemeProvider theme="created-theme">components</ThemeProvider>

For typography  "import Typography from '@material-ui/core/Typography'".
The Typography component can be used like this <Typography parameters>TEXT</Typography>, different parameter possibilities are for example: variant, size...

Container component can be used to make content not take the whole screen place but a subsection of it.
Grid component can be used for custom place/space wherein other components can come, thus lay-out all the components where we want to.
Grids and containers can be used for responsive design, meaning proper display on screens of different sizes.

To create an app-bar:
"import AppBar from '@material-ui/core/AppBar'"
"import Toolbar from '@material-ui/core/Toolbar'"
"import IconButton from '@material-ui/core/IconButton'"
"import MenuIcon from '@material-ui/icons/MenuIcons'"
The MenuIcon must come inside an IconButton, which has to come inside a ToolBar, which has to come inside an AppBar.

======
NODEJS
======
SETUP
-----
Install nodejs from the web or with brew on mac. To verify it exists type node --version in terminal.

The node command will compile and execute javascript in the terminal instead of in the browser, by using console.log() you write into the terminal.
node only executes one file, but this file can import from other files.

npm(nodejs-package-manager) command enables to install packages/modules/dependencies(those names are all referring to the same). Those packages can be installed with -g globally or locally (solely on current project). 
Those packages can also be uninstalled.
"npm init" creates a package.json file which stores important info about the package/project.
npx(nodejs-package-execute), executes packages can start apps for example "npx create-react-app".

USE
---
Default global variables; __dirname, __filename, require(imports), module(info module), process (info env).

To export code go to the module and make the variable 'module.exports' equal to what you want to export, if multiple exports set them in an object or make multiple 'module.exports.NameExport'.
To import that code make a variable equal require('modulePath'), by calling require the code on the module/file will be executed.

A lot of built-in modules with lots of different functions already exist. 
Nodejs.org/en/docs/ for more info on all posibilities.

OS module, import it with "const os = require('os')". Gives all the information surrounding the operating system and its user.
path module, helps work with paths.

The http module enables us to create a server, with createServer and listen functions. 
The createServer function takes a function that will loop indefinitively waiting for requests and responding, this function takes two parameters the request and response objects to access/enable requests/responses.
The response object can fill header and status code of reponse with .writeHeader, fillbody of reponse with .write and end the communication with .end.
From the request object access .method, .url...

Javascript is synchronous and single threaded.
While making an external request and waiting for a response our sole thread loses its time. 
Event loops are asynchronous and take a function/callback that makes an external request, while waiting for the response it starts executing the following code outside the function, once a response arrives it comes back to finish execution of that function. Use async/await/promises to setup event loops.

Events occur from users for example clikcing on a button, then an event/function will be called.
The 'events' module element 'EventEmitter' has to be imported, it will allow use to create an EventEmitter object.
This object has the 'on' function that takes a keyword and function, it also has an emit function that takes a keyowrd and optionally parameter values for the function it will end up calling.
If the 'emit' function calls a keyowrd, the function given as argument to the 'on' function with same keyword will be called.
http module has own event functions.

fs module, short for file system, this module enables to handle files, like reading and writing. This can be done in an asynchronous way to gain time if using large files.
FileSync is used to access whole file at once and does not work well on large files.
Streams are used to read large files and allow more customization. ReadStream, WriteStream, DuplexStream exist.

=======
EXPRESS 
=======
SETUP
-----
Has to be used on a nodejs environment as it is a nodejs framework.
For installation use node-package-manager "npm install express".

import it with "const express = require('express');".

USE
---
The express() function creates an app object.
The app object has the following methods: .get, .post, .put, .delete, .all, .use, .listen.
Listen takes port as first parameter and a callback function called once function is created as second parameter.
Get takes a path/url as first argument and as second argument a callback function, called each time a user makes a get request to the path/url, this callback function takes request and response object as parameters. 
Post, put, delete can be used in a similar way as get function but your callback function has to be appropriate to the method.
All refers to all the different methods and in combination with the path '*' (all urls), can be used to make custom responses toward request mistakes.
Use calls middleware.

For express, APIs are HTTP interfaces to transfer data, from the back-end to the front-end for example.
Data is send with JSON (JavaScript Object Notation). 
JSON uses human-readable text to store and transmit data objects consisting of attributeâ€“value pairs and arrays.
With the above mentionned response and request objects the json method can be used to transform arrays of objects into json.
To setup an API use .get method of express with as first parameter the api path/url, in the callback function return the JSON content, the JSON content will be accessible for the front-end by fetching the specified path/url.

Static assets are files that the server does not need to change.???
An url ending with a '?' is followed by parameters with values that the server can use, this is called a query string and can be accessed with the request object's query method.

Why is middleware useful???
Middleware refers to code between server request and response.
The .get method normally has first parameter path and second parameter callback function, it can also have three parameters with as second parameter the middleware function and last parameter the callback function.
This middleware function takes request, response and next object, the next parameter is used to indicate the end of the middleware function and go to the next middleware function or to the final callback function.
Express's use method takes a middleware function and invokes it for any path/url/route, besides if you add a second argument path, than the middleware function will be invoked for all the urls/paths coming from this path.
For use and get to take multiple middleware functions those have to be set in an array.

express's route method allow for the creation of a router object. ???

==========
POSTGRESQL
==========
UNDERSTAND
----------
Is a database-management-system, it uses SQL as its main query language.
A database is used to store, update and retrieve data.
SQL is a programming language to communicate with databases that is widely used.

Data is stored in tables that consist of rows and columns.

SETUP
-----
Has to be downloaded as an app from the web.
For access to the terminal command psql set in .zshrc "export PATH=$PATH:/pathFoundInPostgresqlApp"
Or use brew install.

When launching psql, you can start launching psql commands in the terminal with /? you can view the usage guide and with /l you can list the whole database.
Inside .sql files you can write SQL scripts. Execute them with /i.

USE
---
To create a new database use "CREATE DATABASE name;".
To connect to the database use "psql -h ipAddress -p port nameDatabase" or "\c nameDatabase".
To delete a database use "DROP DATABASE name;".
To delete specific rows, use "DELETE FROM tableName WHERE clumnName=value;", to delete all rows "DELETE FROM tableName;".
To create a table use "CREATE TABLE tableName (
									columnName dataType flags/constraints, 
									columnName2 dataType flags/constraints, 
									columnName3 dataType flags/constraints, 
									);"
The "NON NULL" contraint obligates the column to be filled when filling the row.
To insert data "INSERT INTO nameDatabse (columnName1, columnName2) VALUES (valueColumn1, valueColumn2);".
To make updates "UPDATE tableName SET columnName1 = value1, columnName2 = value2  WHERE id=idNumber".

To get specific columns from a table use "SELECT columnNamesSeparatedByComma FROM tableName;" with '*' to select all columns.
To sort based on specific column "SELECT * FROM tableName ORDER BY columnName;", it will order in terms of the alphabet, numerical system or dates, to reverse the base order add at end command DESC.
To filter the data use "SELECT * FROM tableName WHERE columnName = value;" to set multiple conditions you can add to the command "ADD newCondition", () and OR can be used too. Comparison operators; =, <, >, <=, >=, <>(not equal).
To select only x number of first rows "SELECT * FROM tableName LIMIT x", to only select x->y number of rows "SELECT * FROM tableName OFFSET x LIMIT y - x;".
To get all rows between two values "SELECT * FROM tableName WHERE columnName BETWEEN value1 and value2;".
To get all values starting/ending with particular value "SELECT * FROM databaseName WHERE tableName LIKE 'startValue%endValue';".
To know how much rows with a certain value of a certain column exist "SELECT columnName, count(*) FROM tableName GROUP BY columnName ORDER BY columnName;". 
The count function is called an aggregate function and different ones exist, such as MAX(columnName), MIN(columnName), AVG(columnName), SUM(columnName), )using multiple ones is also possible such as ROUND(AVG(columnName), numberDecimals).
To filter values with certain amount of rows "SELECT columnName, count(*) FROM tableName GROUP BY columnName HAVING COUNT(*) comparison ORDER BY columnName;"
To give name to new columnName use "AS newColumnName".
"COALESCE(defaultValue)" allows to fill empty or undefined values with default values.
Arithmetic operators: + - * / %(modulo) ^(power) !(factorial)
Use DATE() for date + time or DATE()::DATE for only date or DATE()::TIME for only time. With 'INTERVAL "amountOfTime"' you can add or substract the time. To get even more precise values you can "SELECT EXTRACT(YEAR/DAY/... FROM NOW())".
To view all different values in a column "SELECT DISTINCT columnName FROM tableName;".

Primary keys are identifiers, an index for the rows of the table, it is possible to have multiple of them, they are indicated by using the flag PRIMARY KEY at table creation.
Tables can be linked together, this is called relational tables.
A foreign key allows to nest tables inside each other, a person table can have a car for example and this car can be identified by another table, they are connected through a foreign key.
A foreign key is a column that references a primary key in another table. To create a foreign key add at end of column creation command "REFERENCES linkedTableName(columnName)".
Inner joins allows us to join two tables that are connected through a foreign key with "SELECT * FROM table1 JOIN table2 ON table1.foreignKey = table2.primaryKey;".
Not all columns contain foreign keys, left joins allow us to also take them in account in the final output with "LEFT JOIN" instead of "JOIN".

Constraints can also be added, a constraint is for example, all the values inside the email column have to be unique, this would be indicated with "ALTER TABLE tableName ADD CONSTRAINT nameConstraint UNIQUE (columnName);" this constraint caan be removed with "ALTER TABLE tableName DROP CONSTRAINT nameConstraint;". With the use of CHECK (condition) instead of UNIQUE, you can choose own condition.
If the constraint condition is met a conflict occurs which will block the action from taking place, to make an exception add at end of insert command "ON CONFLICT constraintName DO UPDATE SET columnName = EXCLUDED.columnName;".

Columns can also contain as value a sequence. This is a type that yields ever increasing values, the value can be reset and increases each time it is selected with SELECT. It gets indicated when creating a table with the BIGSERIAL type, it can be used for the primary-key/id column.
Extensions are functions that can be viewed with "SELECT FROM pg_available_extensions;", those can add various functionalities like universally unique identifiers.
UUIDs can be installed with "CREATE EXTENSION IF NOT EXISTS 'uuid-ossp';", using "SELECT uuid_generate_v4();" you can generate a random UUID, using UUIDs as primary keys can protect against attackers that want to mine the database, it also allows for merging databses without conflicts.
To use UUIDS as primary key, use the UUID type for the primary key and uuid_generate_v4() function to insert the appropriate values.

Generate a .csv file, "\copy (SELECT command to take wanted code from tables) TO .csvPath DELIMITER "," CSV HEADER;"
